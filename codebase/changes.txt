======================
 CODEBASE Ã„NDERUNGEN
======================

ðŸ“‚ GeÃ¤nderte & neue Dateien:

- app/api/session/route.ts
- app/tools/wordprocess/page.tsx
- codebase.sh
- codebase/changes.json
- codebase/changes.txt
- components/typewriter/editor.tsx
- lib/context/SessionContext.tsx
- lib/db.ts
- lib/db/client.ts
- lib/validation.tsx

======================
 DATEIINHALTE
======================

--------------------------------------
ðŸ“„ Datei: app/api/session/route.ts
--------------------------------------
import { NextRequest, NextResponse } from 'next/server';
import { query } from '@/lib/db/client';
import { validateSessionContent } from '@/lib/validation';

export const runtime = 'edge'; // FÃ¼r Vercel Edge Functions

export async function POST(req: NextRequest) {
  const { content, sessionId } = await req.json();

  if (!validateSessionContent(content)) {
    return NextResponse.json(
      { error: 'Invalid content format' },
      { status: 400 },
    );
  }

  try {
    const result = await query(
      `INSERT INTO sessions (content, ip_address)
      VALUES ($1, $2)
      RETURNING id, created_at`,
      [content, req.ip],
    );

    return NextResponse.json(result.rows[0]);
  } catch (error) {
    console.error('Database Error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 },
    );
  }
}





--------------------------------------
ðŸ“„ Datei: components/typewriter/editor.tsx
--------------------------------------
// components/Editor.tsx
import React, { useEffect, useCallback } from 'react';
import { useSession } from '@/lib/context/SessionContext';
import useSound from 'use-sound';
import typewriterSound from '@/public/sounds/typewriter.mp3';

export default function Editor() {
  const { state, dispatch } = useSession();
  const [play] = useSound(typewriterSound, { volume: 0.5 });

  // Soundeffekt bei jedem Tastendruck
  const handleKeyPress = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === 'Backspace') {
        e.preventDefault(); // Backspace deaktivieren
        return;
      }

      if (e.key.length === 1) {
        play(); // Soundeffekt abspielen
        dispatch({ type: 'APPEND_CONTENT', payload: e.key }); // Text hinzufÃ¼gen
      }
    },
    [dispatch, play],
  );

  // Automatisches Speichern alle 5 Sekunden
  useEffect(() => {
    const autoSave = setInterval(() => {
      if (state.content.length >= 10) {
        fetch('/api/session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: state.content }),
        });
      }
    }, 5000);

    return () => clearInterval(autoSave);
  }, [state.content]);

  return (
    <textarea
      value={state.content}
      onKeyDown={handleKeyPress}
      className="w-full h-screen p-4 bg-black text-white font-mono text-lg outline-none resize-none"
      autoFocus
    />
  );
}


--------------------------------------
ðŸ“„ Datei: lib/context/SessionContext.tsx
--------------------------------------
// lib/context/SessionContext.tsx
import React, { createContext, useReducer, useContext, ReactNode } from 'react';

// Typdefinitionen
interface SessionState {
  content: string;
  isLocked: boolean;
  wordCount: number;
  lastSavedAt: Date | null;
}

type SessionAction =
  | { type: 'APPEND_CONTENT'; payload: string }
  | { type: 'LOCK_SESSION' }
  | { type: 'UNLOCK_SESSION' }
  | { type: 'UPDATE_WORD_COUNT'; payload: number }
  | { type: 'UPDATE_LAST_SAVED'; payload: Date };

interface SessionContextType {
  state: SessionState;
  dispatch: React.Dispatch<SessionAction>;
}

// Initialer Zustand
const initialState: SessionState = {
  content: '',
  isLocked: false,
  wordCount: 0,
  lastSavedAt: null,
};

// Reducer-Funktion
const sessionReducer = (
  state: SessionState,
  action: SessionAction,
): SessionState => {
  switch (action.type) {
    case 'APPEND_CONTENT':
      return {
        ...state,
        content: state.content + action.payload,
      };
    case 'LOCK_SESSION':
      return {
        ...state,
        isLocked: true,
      };
    case 'UNLOCK_SESSION':
      return {
        ...state,
        isLocked: false,
      };
    case 'UPDATE_WORD_COUNT':
      return {
        ...state,
        wordCount: action.payload,
      };
    case 'UPDATE_LAST_SAVED':
      return {
        ...state,
        lastSavedAt: action.payload,
      };
    default:
      return state;
  }
};

// Context erstellen
const SessionContext = createContext<SessionContextType | undefined>(undefined);

// Provider-Komponente
export const SessionProvider = ({ children }: { children: ReactNode }) => {
  const [state, dispatch] = useReducer(sessionReducer, initialState);

  return (
    <SessionContext.Provider value={{ state, dispatch }}>
      {children}
    </SessionContext.Provider>
  );
};

// Hook fÃ¼r einfachen Zugriff auf den Context
export const useSession = () => {
  const context = useContext(SessionContext);
  if (!context) {
    throw new Error(
      'useSession muss innerhalb eines SessionProviders verwendet werden',
    );
  }
  return context;
};


--------------------------------------
ðŸ“„ Datei: lib/db.ts
--------------------------------------
import { Pool } from 'pg';

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

export const query = (text: string, params?: any[]) => pool.query(text, params);


--------------------------------------
ðŸ“„ Datei: lib/db/client.ts
--------------------------------------
import { Pool, PoolConfig } from 'pg';
import { parse } from 'pg-connection-string';

// Typisierte Konfiguration fÃ¼r die Datenbankverbindung
interface DatabaseConfig extends PoolConfig {
  ssl?: boolean | { rejectUnauthorized: boolean };
}

// Parse DATABASE_URL und konvertiere in PoolConfig
const connectionConfig = parse(process.env.DATABASE_URL!);

// Explizite Typisierung der Konfiguration
const poolConfig: DatabaseConfig = {
  host: connectionConfig.host || 'localhost',
  port: connectionConfig.port ? parseInt(connectionConfig.port) : 5432,
  user: connectionConfig.user || 'postgres',
  password: connectionConfig.password || undefined,
  database: connectionConfig.database || 'typewriter', // Fallback auf 'typewriter'
  ssl:
    process.env.NODE_ENV === 'production'
      ? { rejectUnauthorized: false }
      : false,
};

// Erstelle den Pool mit der typisierten Konfiguration
const pool = new Pool(poolConfig);

// Exportiere die query-Funktion
export const query = (text: string, params?: any[]) => pool.query(text, params);


--------------------------------------
ðŸ“„ Datei: lib/validation.tsx
--------------------------------------
// lib/validation.ts

/**
 * Validiert den Inhalt einer Schreibsession
 * @param content - Der zu validierende Inhalt
 * @returns boolean - true, wenn der Inhalt gÃ¼ltig ist
 */
export function validateSessionContent(content: string): boolean {
  if (!content || typeof content !== 'string') {
    return false;
  }

  // Mindestens 10 Zeichen und 3 WÃ¶rter
  const words = content.trim().split(/\s+/);
  return content.length >= 10 && words.length >= 3;
}

/**
 * Validiert eine Session-ID
 * @param sessionId - Die zu validierende ID
 * @returns boolean - true, wenn die ID gÃ¼ltig ist
 */
export function validateSessionId(sessionId: string): boolean {
  return /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}$/i.test(
    sessionId,
  );
}


